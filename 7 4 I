"""I. Снеговики
Тренировки по алгоритмам 7.0 от Яндекса — Занятие 4 (Ссылочные типы данных, двусвязные списки, B-деревья)
https://contest.yandex.ru/contest/27472/problems/C/

Ограничение времени	4 секунды
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Зима. 2012 год. На фоне грядущего Апокалипсиса и конца света незамеченной прошла новость об очередном прорыве в областях клонирования и снеговиков: клонирования снеговиков. Вы конечно знаете, но мы вам напомним, что снеговик состоит из нуля или более вертикально поставленных друг на друга шаров, а клонирование — это процесс создания идентичной копии (клона).

В местечке Местячково учитель Андрей Сергеевич Учитель купил через интернет-магазин «Интернет-магазин аппаратов клонирования» аппарат для клонирования снеговиков. Теперь дети могут играть и даже играют во дворе в следующую игру. Время от времени один из них выбирает понравившегося снеговика, клонирует его и:

либо добавляет ему сверху один шар;
либо удаляет из него верхний шар (если снеговик не пустой).
Учитель Андрей Сергеевич Учитель записал последовательность действий и теперь хочет узнать суммарную массу всех построенных снеговиков.

Формат ввода
Первая строка содержит количество действий n (1 ≤ n ≤ 200 000). В строке номер i + 1 содержится описание действия i:

t m — клонировать снеговика номер t (0 ≤ t < i) и добавить сверху шар массой m (0 < m ≤ 1000);
t 0 — клонировать снеговика номер t (0 ≤ t < i) и удалить верхний шар. Гарантируется, что снеговик t не пустой.
В результате действия i, описанного в строке i + 1 создается снеговик номер i. Изначально имеется пустой снеговик с номером ноль.
Все числа во входном файле целые.

Формат вывода
Выведите суммарную массу построенных снеговиков."""

import sys

def main():
    # Чтение всех входных данных за один раз для ускорения работы
    input = sys.stdin.read().split()
    ptr = 0  # Указатель на текущую позицию в массиве входных данных
    
    # Чтение количества операций
    n = int(input[ptr])
    ptr += 1
    
    sum = 0  # Общая сумма всех значений массивов
    arrays = [0] * (n + 1)  # Текущие значения массивов (индексация с 1)
    arrayprev = [0] * (n + 1)  # Массив для хранения предпоследних состояний (для операции m=0)

    # Обработка каждой операции
    for i in range(1, n + 1):
        # Чтение номера массива-источника и значения m
        t = int(input[ptr])
        ptr += 1
        m = int(input[ptr])
        ptr += 1
        
        if m == 0:
            # Операция отката: берем значение из предпоследнего состояния массива t
            arrays[i] = arrays[arrayprev[t]]
            
            # Обновляем предпоследнее состояние для текущего массива
            if arrayprev[t] == 0:
                arrayprev[i] = 0  # Если нет предпоследнего состояния
            else:
                arrayprev[i] = arrayprev[arrayprev[t]]  # Иначе берем предыдущее состояние из цепочки
            
            sum += arrays[i]
        else:
            # Обычная операция: добавляем m к массиву t
            arrays[i] = arrays[t] + m
            arrayprev[i] = t  # Запоминаем текущее состояние как предыдущее для будущих откатов
            sum += arrays[i]
    
    # Вывод общей суммы
    print(sum)

if __name__ == '__main__':
    main()
