F. Свинки-копилки
Тренировки по алгоритмам 7.0 от Яндекса — Занятие 4 (Ссылочные типы данных, двусвязные списки, B-деревья)
https://contest.yandex.ru/contest/74968/problems/F/

Ограничение времени	1 секунда
Ограничение памяти	64 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
У Васи есть N свинок-копилок, свинки занумерованы числами от 1 до N. Каждая копилка может быть открыта единственным соответствующим ей ключом или разбита.

Вася положил ключи в некоторые из копилок (он помнит, какой ключ лежит в какой из копилок). Теперь Вася собрался купить машину, а для этого ему нужно достать деньги из всех копилок. При этом он хочет разбить как можно меньшее количество копилок (ведь ему ещё нужно копить деньги на квартиру, дачу, вертолет…). Помогите Васе определить, какое минимальное количество копилок нужно разбить.

Формат ввода
В первой строке содержится число N — количество свинок-копилок (1 ≤ N ≤ 100000). Далее идет N строк с описанием того, где лежит ключ от какой копилки: в i-ой из этих строк записан номер копилки, в которой находится ключ от i-ой копилки.

Формат вывода
Выведите единственное число: минимальное количество копилок, которые необходимо разбить.

import sys

def main():
    """
    Основная функция для обработки входных данных и подсчета уникальных "копилок".
    Алгоритм использует модифицированную версию структуры данных Union-Find для
    эффективного отслеживания связей между элементами.
    """
    # Чтение входных данных
    input = sys.stdin.read().split()
    ptr = 0  # Указатель на текущую позицию в входных данных
    n = int(input[ptr])  # Количество элементов
    ptr += 1
    col = 0  # Счетчик уникальных "копилок"
    
    # Инициализация массива для хранения связей:
    #   -1 - элемент является корнем (копилкой)
    #    0 - элемент не обработан
    #   >0 - ссылка на родительский элемент
    arrays = [0] * (n + 1)  # Индексация от 1 до n
    
    for i in range(1, n + 1):
        el = int(input[ptr])  # Текущий элемент
        ptr += 1
        
        # Случай 1: Оба элемента не обработаны
        if arrays[el] == 0 and arrays[i] == 0:
            arrays[i] = el    # Связываем i с el
            arrays[el] = -1   # Помечаем el как корень
            col += 1          # Увеличиваем счетчик копилок
        
        # Случай 2: el - корень, i не обработан
        elif arrays[el] == -1 and arrays[i] == 0:
            arrays[i] = el    # Просто связываем i с существующей копилкой el
        
        # Случай 3: el имеет родителя, i не обработан
        elif arrays[el] > 0 and arrays[i] == 0:
            arrays[i] = arrays[el]  # Связываем i с родителем el
        
        # Случай 4: el не обработан, i - корень
        elif arrays[el] == 0 and arrays[i] == -1:
            arrays[el] = i     # Связываем el с существующей копилкой i
        
        # Случай 5: Оба элемента являются корнями
        elif arrays[el] == -1 and arrays[i] == -1:
            if i != el:        # Если это разные копилки
                arrays[i] = el # Объединяем их
                col -= 1       # Уменьшаем счетчик копилок
        
        # Случай 6: el имеет родителя, i - корень
        elif arrays[el] > 0 and arrays[i] == -1:
            if arrays[el] != i and i != el:
                # Находим корень для el
                rel = arrays[el]
                while arrays[rel] != -1:
                    rel = arrays[rel]
                # Если корни разные - объединяем
                if rel != i:
                    arrays[el] = i
                    arrays[rel] = i
                    col -= 1
        
        # Случай 7: el не обработан, i имеет родителя
        elif arrays[el] == 0 and arrays[i] > 0:
            arrays[el] = arrays[i]  # Связываем el с родителем i
        
        # Случай 8: el - корень, i имеет родителя
        elif arrays[el] == -1 and arrays[i] > 0:
            # Находим корень для i
            rel = arrays[i]
            while arrays[rel] != -1:
                rel = arrays[rel]
            # Если корни разные - объединяем
            if rel != el:
                arrays[i] = el
                arrays[rel] = el
                col -= 1
        
        # Случай 9: Оба элемента имеют родителей
        elif arrays[el] > 0 and arrays[i] > 0:
            if i != el:
                # Находим корни для обоих элементов
                rel = arrays[el]
                while arrays[rel] != -1:
                    rel = arrays[rel]
                ri = arrays[i]
                while arrays[ri] != -1:
                    ri = arrays[ri]
                # Если корни разные - объединяем
                if rel != ri:
                    arrays[ri] = rel
                    col -= 1
    
    print(col)  # Выводим количество уникальных копилок

if __name__ == '__main__':
    main()
