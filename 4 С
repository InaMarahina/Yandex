"""
C. Дек с защитой от ошибок
Тренировки по алгоритмам 7.0 от Яндекса — Занятие 4 (Ссылочные типы данных, двусвязные списки, B-деревья)
https://contest.yandex.ru/contest/74968/problems/C/

Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Научитесь пользоваться стандартной структурой данных deque для целых чисел.  Напишите программу, содержащую описание дека и моделирующую работу дека, реализовав все указанные здесь методы. Программа считывает последовательность команд и в зависимости от команды выполняет ту или иную операцию. После выполнения каждой команды программа должна вывести одну строчку.

Возможные команды для программы:

push_front n
Добавить (положить) в начало дека новый элемент. Программа должна вывести ok.

push_back n
Добавить (положить) в конец дека новый элемент. Программа должна вывести ok.

pop_front
Извлечь из дека первый элемент. Программа должна вывести его значение.

pop_back
Извлечь из дека последний элемент. Программа должна вывести его значение.

front
Узнать значение первого элемента (не удаляя его). Программа должна вывести его значение.

back
Узнать значение последнего элемента (не удаляя его). Программа должна вывести его значение.

size
Вывести количество элементов в деке.

clear
Очистить дек (удалить из него все элементы) и вывести ok.

exit
Программа должна вывести bye и завершить работу.

Гарантируется, что количество элементов в деке в любой момент не превосходит 100. Перед исполнением операций pop_front, pop_back, front, back программа должна проверять, содержится ли в деке хотя бы один элемент. Если во входных данных встречается операция pop_front, pop_back, front, back, и при этом дек пуст, то программа должна вместо числового значения вывести строку error.

Формат ввода
Вводятся команды управления деком, по одной на строке.

Формат вывода
Требуется вывести протокол работы дека, по одному сообщению на строке

"""

python
import sys

def main():
    # Инициализация структур данных:
    # stack - основной массив для хранения элементов
    # nextstack - массив индексов следующих элементов (для каждого элемента в stack)
    # prevstack - массив индексов предыдущих элементов (для каждого элемента в stack)
    # head - индекс первого элемента в деке
    # tail - индекс последнего элемента в деке
    # colel - количество элементов в деке
    stack = []
    nextstack = []
    prevstack = []
    head = -1  # -1 означает, что дек пуст
    tail = -1
    colel = 0

    while True:
        # Чтение команды из стандартного ввода
        command = input().split()

        # Команда выхода из программы
        if command[0] == 'exit':
            print('bye')
            return

        # Добавление элемента в начало дека
        elif command[0] == 'push_front':
            stack.append(int(command[1]))  # Добавляем элемент в конец массива
            prevstack.append(None)  # Для нового элемента предыдущего элемента нет

            if colel == 0:  # Если дек был пуст
                head = 0
                tail = 0
                nextstack.append(None)  # Следующего элемента нет
            else:
                nextstack.append(head)  # Новый элемент указывает на старый head
                prevstack[head] = len(stack) - 1  # Старый head теперь указывает назад на новый элемент
                head = len(stack) - 1  # Обновляем head
            colel += 1
            print('ok')

        # Добавление элемента в конец дека
        elif command[0] == 'push_back':
            stack.append(int(command[1]))  # Добавляем элемент в конец массива
            nextstack.append(None)  # Для нового элемента следующего элемента нет

            if colel == 0:  # Если дек был пуст
                head = 0
                tail = 0
                prevstack.append(None)  # Предыдущего элемента нет
            else:
                prevstack.append(tail)  # Новый элемент указывает на старый tail
                nextstack[tail] = len(stack) - 1  # Старый tail теперь указывает вперед на новый элемент
                tail = len(stack) - 1  # Обновляем tail
            colel += 1
            print('ok')

        # Удаление элемента из начала дека
        elif command[0] == 'pop_front':
            if colel > 1:  # Если в деке больше одного элемента
                print(stack[head])  # Выводим значение head
                head = nextstack[head]  # Перемещаем head на следующий элемент
                colel -= 1
                prevstack[head] = None  # У нового head нет предыдущего элемента

            elif colel == 1:  # Если в деке ровно один элемент
                print(stack[head])
                # Очищаем все структуры данных
                stack.clear()
                nextstack.clear()
                prevstack.clear()
                head = -1
                tail = -1
                colel = 0

            else:  # Если дек пуст
                print('error')

        # Удаление элемента из конца дека
        elif command[0] == 'pop_back':
            if colel > 1:  # Если в деке больше одного элемента
                nextstack[prevstack[tail]] = None  # Предпоследний элемент теперь последний
                print(stack[tail])  # Выводим значение tail
                tail = prevstack[tail]  # Перемещаем tail на предыдущий элемент
                colel -= 1

            elif colel == 1:  # Если в деке ровно один элемент
                print(stack[tail])
                # Очищаем все структуры данных
                stack.clear()
                nextstack.clear()
                prevstack.clear()
                head = -1
                tail = -1
                colel = 0

            else:  # Если дек пуст
                print('error')

        # Получение первого элемента дека без удаления
        elif command[0] == 'front':
            if head != -1:  # Если дек не пуст
                print(stack[head])
            else:
                print('error')

        # Получение последнего элемента дека без удаления
        elif command[0] == 'back':
            if head != -1:  # Если дек не пуст
                print(stack[tail])
            else:
                print('error')

        # Получение размера дека
        elif command[0] == 'size':
            if head == -1:  # Если дек пуст
                print(0)
            else:
                print(colel)

        # Очистка дека
        elif command[0] == 'clear':
            stack.clear()
            nextstack.clear()
            prevstack.clear()
            head = -1
            tail = -1
            colel = 0
            print('ok')

if __name__ == '__main__':
    main()


