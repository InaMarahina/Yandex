"""J. Простая река
Тренировки по алгоритмам 7.0 от Яндекса — Занятие 4 (Ссылочные типы данных, двусвязные списки, B-деревья)
https://contest.yandex.ru/contest/74968/problems/J/

Ограничение времени	2 секунды
Ограничение памяти	256 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Во Флатландии протекает богатая рыбой река Большой Флат. Много лет назад река была поделена между 
n рыболовными предприятиями, каждое из которых получило непрерывный отрезок реки. При этом 
i -е предприятие, если рассматривать их по порядку, начиная от истока, изначально получило отрезок реки длиной 
ai
С тех пор с рыболовными предприятиями во Флатландии 
k раз происходили различные события. Каждое из событий было одного из двух типов: банкротство некоторого предприятия или разделение некоторого предприятия на два.
При некоторых событиях отрезок реки, принадлежащий предприятию, с которым это событие происходит, делится на две части. Каждый такой отрезок имеет длину большую или равную 2. Деление происходит по следующему правилу. Если отрезок имеет чётную длину, то он делится на две равные части. Иначе он делится на две части, длины которых различаются ровно на единицу, при этом часть, которая ближе к истоку реки, имеет меньшую длину.
При банкротстве предприятия происходит следующее. Отрезок реки, принадлежавший обанкротившемуся предприятию, переходит к его соседям. Если у обанкротившегося предприятия один сосед, то этому соседу целиком передается отрезок реки обанкротившегося предприятия. Если же соседей двое, то отрезок реки делится на две части описанным выше способом, после чего каждый из соседей присоединяет к своему отрезку ближайшую к нему часть.
При разделении предприятия отрезок реки, принадлежавший разделяемому предприятию, всегда делится на две части описанным выше способом. Разделившееся предприятие ликвидируется, и образуются два новых предприятия. Таким образом, после каждого события каждое предприятие владеет некоторым отрезком реки.
Министерство финансов Флатландии предлагает ввести налог на рыболовные предприятия, пропорциональный квадрату длины отрезка реки, принадлежащего соответствующему предприятию. Чтобы проанализировать, как будет работать этот налог, министр хочет по имеющимся данным узнать, как изменялась величина, равная сумме квадратов длин отрезков реки, принадлежащих предприятиям, после каждого произошедшего события.
Требуется написать программу, которая по заданному начальному разделению реки между предприятиями и списку событий, происходивших с предприятиями, определит, чему равна сумма квадратов длин отрезков реки, принадлежащих предприятиям, в начальный момент времени и после каждого события.
"""
import sys

def main():
    # Чтение всех входных данных за один раз для ускорения работы
    input = sys.stdin.read().split()
    ptr = 0  # Указатель на текущую позицию в массиве входных данных
    
    # Чтение количества элементов в начальном массиве
    n = int(input[ptr])
    ptr += 1
    
    # Инициализация начального массива и вычисление суммы квадратов
    arrays = [0] + [int(x) for x in input[1:n+1]]
    sumsquar = sum(x ** 2 for x in arrays)
    ptr += n
    
    # Чтение количества событий
    m = int(input[ptr])
    ptr += 1
    
    # Инициализация структур данных для работы со списком:
    # array - значения элементов (индексация с 1)
    # arrayprev - указатели на предыдущие элементы
    # arraynext - указатели на следующие элементы
    array = list(range(n+1))
    arrayprev = [None] + [None] + list(range(1, n))  # указатель
    arraynext = [None] + list(range(2, n+1)) + [None]  # указатель
    
    # Инициализация счетчиков и указателей:
    colel = n      # Текущее количество элементов
    coladd = n     # Счетчик добавленных элементов
    head = 1       # Указатель на первый элемент
    tail = n       # Указатель на последний элемент
    
    # Массив для хранения ответов
    answ = ['']*(m+1)
    answ[0] = str(sumsquar)  # Начальное значение суммы квадратов

    # Обработка событий
    for j in range(m):
        event = input[ptr]  # Тип события ('1' или '2')
        ptr += 1
        i = int(input[ptr])  # Номер элемента, к которому применяется событие
        ptr += 1
        
        # Определение текущей позиции jj в списке
        if j == 0:
            jj = i  # Для первого события берем элемент напрямую
        else:
            # Оптимизация перемещения по списку:
            if i == 1:
                jj = head  # Если нужен первый элемент
            elif i > jjnum:
                # Двигаемся вперед по списку
                for _ in range(i - jjnum):
                    jj = arraynext[jj]
            elif i < jjnum:
                # Двигаемся назад по списку
                for dd in range(jjnum - i):
                    jj = arrayprev[jj]
        
        next = arraynext[jj]  # Следующий элемент
        
        if event == '1':  # Событие "банкрот" (объединение с соседями)
            prev = arrayprev[jj]  # Предыдущий элемент
            
            if prev == None:  # Если текущий элемент первый
                # Объединяем с следующим
                sumsquar += - arrays[jj]**2 - arrays[next]**2 + (arrays[jj]+arrays[next])**2
                arrays[next] += arrays[jj]
                arrayprev[next] = None
                head = next  # Обновляем указатель на начало
                jj = next
                jjnum = 1
                
            elif next == None:  # Если текущий элемент последний
                # Объединяем с предыдущим
                sumsquar += - arrays[jj]**2 - arrays[prev]**2 + (arrays[jj]+arrays[prev])**2
                arrays[prev] += arrays[jj]
                arraynext[prev] = None
                tail = prev  # Обновляем указатель на конец
                jjnum = i - 1
                jj = prev
                
            else:  # Если элемент в середине списка
                prevold = arrays[prev]
                nextold = arrays[next]
                
                # Распределяем значение текущего элемента между соседями
                arrays[prev] += arrays[jj] // 2
                arrays[next] += arrays[jj] // 2
                if arrays[jj] % 2:  # Если нечетное, добавляем 1 к следующему
                    arrays[next] += 1
                
                # Обновляем сумму квадратов
                sumsquar += - arrays[jj]**2 - prevold**2 - nextold**2 + arrays[prev]**2 + arrays[next]**2
                
                # Обновляем связи в списке
                arraynext[prev] = next
                arrayprev[next] = prev
                jj = next
                jjnum = i
            
            colel -= 1  # Уменьшаем количество элементов
            answ[j+1] = str(sumsquar)  # Сохраняем результат

        elif event == '2':  # Событие "деление на 2" (разделение элемента)
            colel += 1     # Увеличиваем количество элементов
            coladd += 1     # Увеличиваем счетчик добавленных элементов
            
            # Создаем новый элемент с половиной значения
            news = arrays[jj]//2
            sumsquar -= arrays[jj]**2  # Корректируем сумму квадратов
            
            if arrays[jj] % 2:  # Если нечетное, добавляем 1 к новому элементу
                news += 1
            
            # Добавляем новый элемент в структуры данных
            arrays.append(news)
            arraynext.append(next)
            arrayprev.append(jj)
            
            if next == None:  # Если текущий элемент был последним
                tail = coladd  # Обновляем указатель на конец
            else:
                arrayprev[next] = coladd  # Обновляем ссылку у следующего элемента
            
            # Обновляем значение текущего элемента
            arrays[jj] = arrays[jj]//2
            arraynext[jj] = coladd  # Устанавливаем ссылку на новый элемент
            
            # Обновляем сумму квадратов
            sumsquar += arrays[jj]**2 + news**2
            jjnum = i
            answ[j+1] = str(sumsquar)  # Сохраняем результат

    # Вывод всех результатов
    sys.stdout.write('\n'.join(answ))

if __name__ == '__main__':
    main()
