""" Задание из https://contest.yandex.ru/contest/74968/problems/A/
Тренировки 7. Этап 1. От Яндекс.
A. Стек с защитой от ошибок
Ограничение времени	1 секунда
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Научитесь пользоваться стандартной структурой данных stack для целых чисел. Напишите программу, содержащую описание стека и моделирующую работу стека, реализовав все указанные здесь методы. Программа считывает последовательность команд и в зависимости от команды выполняет ту или иную операцию. После выполнения каждой команды программа должна вывести одну строчку. Возможные команды для программы:

push n
Добавить в стек число n (значение n задается после команды). Программа должна вывести ok.

pop
Удалить из стека последний элемент. Программа должна вывести его значение.

back
Программа должна вывести значение последнего элемента, не удаляя его из стека.

size
Программа должна вывести количество элементов в стеке.

clear
Программа должна очистить стек и вывести ok.

exit
Программа должна вывести bye и завершить работу.

Перед исполнением операций back и pop программа должна проверять, содержится ли в стеке хотя бы один элемент. Если во входных данных встречается операция back или pop, и при этом стек пуст, то программа должна вместо числового значения вывести строку error.

Формат ввода
Вводятся команды управления стеком, по одной на строке

Формат вывода
Программа должна вывести протокол работы стека, по одному сообщению на строке"""

import sys


def main():
    # Чтение входных данных
    input = sys.stdin.read().split()
    ptr = 0
    n = int(input[ptr])  # Количество элементов в стеке
    ptr += 1
    stack = list(map(int, input[ptr:ptr+n]))  # Сам стек
    
    # Инициализация вспомогательных структур
    nextstack = [0]*n  # Массив для хранения индексов следующих элементов
    res = ['0']*n  # Массив для хранения результатов (раундов удаления)
    colel = n  # Текущее количество элементов в стеке
    head = 0  # Индекс первого элемента в стеке
    tail = n - 1  # Индекс последнего элемента в стеке
    
    # Инициализация связей между элементами (имитация двусвязного списка)
    for i in range(n-1):
        nextstack[i] = i+1
    nextstack[n-1] = 0  # Замыкаем список (последний ссылается на первый)
    
    delcol = 1  # Количество удаленных элементов в текущем раунде
    raund = 0  # Номер текущего раунда
    
    # Основной цикл: выполняется, пока есть что удалять и элементов больше 2
    while colel > 2 and delcol > 0:
        raund += 1
        delcol = 0
        curren = head  # Текущий элемент
        prev = tail    # Предыдущий элемент
        nextel = nextstack[curren]  # Следующий элемент
        flags = False  # Флаг завершения обработки текущего раунда
        lh = 0         # Флаг обработки головы списка
        
        # Внутренний цикл обработки элементов в текущем раунде
        while not flags:
            # Проверка условий завершения обработки раунда
            if curren >= tail:
                flags = True
            if lh == 1:
                if nextstack[curren] >= tail:
                    flags = True
            
            # Проверка условия удаления элемента (он меньше обоих соседей)
            if stack[curren] < stack[prev] and stack[curren] < stack[nextel]:
                if curren == head:
                    head = nextel  # Обновляем голову, если удаляем первый элемент
                    lh = 1
                elif curren == tail:
                    tail = prev    # Обновляем хвост, если удаляем последний элемент
                    flags = True
                
                # Фиксируем раунд удаления и обновляем связи
                res[curren] = str(raund)
                nextstack[prev] = nextel
                delcol += 1
                colel -= 1
                
                # Переход к следующим элементам
                prev = nextel
                curren = nextstack[prev]
                nextel = nextstack[curren]
                
                # Проверка условий завершения
                if prev >= tail or curren > tail:
                    flags = True
            else:
                # Переход к следующему элементу без удаления
                prev = curren
                curren = nextel
                nextel = nextstack[curren]
    
    # Вывод результата
    print(' '.join(res))


if __name__ == '__main__':
    main()
