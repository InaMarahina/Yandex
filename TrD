"""D. Вывести маршрут максимальной стоимости
Тренировки по алгоритмам 7.0 от Яндекса — Разминка
https://contest.yandex.ru/contest/74963/problems/D/
Ограничение времени	1 секунда
Ограничение памяти	256 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В левом верхнем углу прямоугольной таблицы размером 
N
×
M
N×M находится черепашка. В каждой клетке таблицы записано некоторое число. Черепашка может перемещаться вправо или вниз, при этом маршрут черепашки заканчивается в правом нижнем углу таблицы.

Подсчитаем сумму чисел, записанных в клетках, через которые проползла черепашка (включая начальную и конечную клетку). Найдите наибольшее возможное значение этой суммы и маршрут, на котором достигается эта сумма.

Формат ввода
В первой строке входных данных записаны два натуральных числа N и M, не превосходящих 100, — размеры таблицы. Далее идет N строк, каждая из которых содержит M чисел, разделенных пробелами, — описание таблицы. 
Все числа в клетках таблицы целые и могут принимать значения от 0 до 100.

Формат вывода
Первая строка выходных данных содержит максимальную возможную сумму, вторая — маршрут, на котором достигается эта сумма. Маршрут выводится в виде последовательности, которая должна содержать N-1 букву D, 
означающую передвижение вниз и M-1 букву R, означающую передвижение направо. Если таких последовательностей несколько, необходимо вывести ровно одну (любую) из них.
"""
def maxsum2(n, m, table):
    # Создаем матрицу sum_list для хранения максимальных сумм
    sum_list = n*[0]
    i = j = 0
    # Инициализируем матрицу sum_list нулями
    for i in range(n):
        sum_list[i] = [0] * m
    
    # Начальное значение - первый элемент таблицы
    sum_list[0][0] = table[0][0]
    
    # Заполняем первую строку (можем двигаться только вправо)
    for j in range(1, m):
        sum_list[0][j] = sum_list[0][j-1] + table[0][j]
    
    # Заполняем первый столбец (можем двигаться только вниз)
    for i in range(1, n):
        sum_list[i][0] = table[i][0] + sum_list[i-1][0]
        # Заполняем остальные ячейки матрицы
        for j in range(1, m):
            # Выбираем максимальное значение из верхней или левой ячейки
            sum_list[i][j] = max(
                sum_list[i-1][j], sum_list[i][j-1]) + table[i][j]
    
    # Создаем список для хранения пути (D - вниз, R - вправо)
    list_way = ['']*(n + m - 2)
    
    # Восстанавливаем путь от конечной точки к начальной
    while i > 0 or j > 0:
        # Если достигли верхней строки - идем только влево
        if i == 0:
            for jj in range(j):
                list_way[jj] = 'R'
            return sum_list[-1][-1], ' '.join(list_way)
        # Если достигли левого столбца - идем только вверх
        if j == 0:
            for jj in range(i):
                list_way[jj] = 'D'
            return sum_list[-1][-1], ' '.join(list_way)
        # Выбираем направление с максимальной суммой
        if sum_list[i-1][j] > sum_list[i][j-1]:
            i = i - 1
            list_way[i + j] = 'D'  # Движение вниз
        else:
            j = j - 1
            list_way[i + j] = 'R'  # Движение вправо

    return sum_list[-1][-1], ' '.join(list_way)


# Ввод данных
n, m = map(int, input().split())  # Чтение размеров таблицы
array = [list(map(int, input().split())) for i in range(n)]  # Чтение самой таблицы

# Проверка на ненулевые размеры и вызов функции
if n > 0 and m > 0:
    r1, r2 = maxsum2(n, m, array)
    print(r1)  # Вывод максимальной суммы
    print(r2)  # Вывод оптимального пути
