"""
F. Хипуй
https://contest.yandex.ru/contest/74963/problems/F/
Тренировки по алгоритмам 7.0 от Яндекса — Разминка

Ограничение времени	2 секунды
Ограничение памяти	64 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
В этой задаче вам необходимо самостоятельно (не используя соответствующие классы и функции стандартной библиотеки) организовать структуру данных Heap для хранения целых чисел, над которой определены следующие операции:

a) Insert(k) — добавить в Heap число k ;

b) Extract — достать из Heap наибольшее число (удалив его при этом).

Формат ввода
В первой строке содержится количество команд N (1 ≤ N ≤ 100000), далее следуют N команд, каждая в своей строке. Команда может иметь формат: “0 <число>” или “1”, обозначающий, соответственно, операции Insert(<число>) и Extract. Гарантируется, что при выполнении команды Extract в структуре находится по крайней мере один элемент.

Формат вывода
Для каждой команды извлечения необходимо отдельной строкой вывести число, полученное при выполнении команды Extract.
"""

n = int(input())  # Количество операций
aheap = []  # Максимум-куча (max-heap)

for i in range(n):
    # Читаем входные данные (0 X - добавить, 1 - извлечь максимум)
    str = list(map(int, input().split()))
    curpos = len(aheap)  # Текущая позиция в куче
    
    if not str[0]:  # Операция добавления элемента
        aheap.append(str[1])  # Добавляем элемент в конец кучи
        curpos += 1  # Увеличиваем позицию (новый размер кучи)
        
        # Просеивание вверх (поддержание свойства кучи)
        while (curpos > 1 and aheap[curpos-1] > aheap[curpos//2 - 1]):
            # Меняем местами с родителем, если текущий элемент больше
            hel = aheap[curpos-1]
            aheap[curpos-1] = aheap[curpos//2 - 1]
            aheap[curpos//2 - 1] = hel
            curpos = curpos//2  # Переходим к родителю
    
    else:  # Операция извлечения максимума
        if not aheap:  # Если куча пуста
            print(-1)  # Можно добавить обработку ошибки
            continue
            
        print(aheap[0])  # Выводим максимум (корень кучи)
        # Заменяем корень последним элементом
        aheap[0] = aheap[curpos-1]
        aheap.pop()  # Удаляем последний элемент
        curpos = 1  # Начинаем просеивание вниз с корня
        
        # Просеивание вниз (поддержание свойства кучи)
        while (curpos*2 == len(aheap) and aheap[curpos*2-1] > aheap[curpos-1]) or \
              ((curpos*2 < len(aheap)) and ((aheap[curpos*2 - 1] > aheap[curpos-1]) or \
                                           (aheap[curpos*2] > aheap[curpos-1]))):
            cur_f = 0  # Флаг выбора потомка (0 - правый, 1 - левый)
            
            # Выбираем наибольшего потомка
            if (curpos*2 == len(aheap)) or \
               ((aheap[curpos*2-1] > aheap[curpos-1]) and \
                (aheap[curpos*2-1] >= aheap[curpos*2])):
                cur_f = 1  # Выбираем левого потомка
            
            # Меняем местами с выбранным потомком
            hel = aheap[curpos - 1]
            aheap[curpos - 1] = aheap[curpos*2 - cur_f]
            aheap[curpos*2 - cur_f] = hel
            curpos = curpos*2 - cur_f + 1  # Переходим к потомку
