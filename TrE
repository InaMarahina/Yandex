"""E. Кафе
Тренировки по алгоритмам 7.0 от Яндекса — Разминка
https://contest.yandex.ru/contest/27472/problems/I/
Ограничение времени	1 секунда
Ограничение памяти	64 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует воспользоваться купонами.

Формат ввода
В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число, не превосходящее 300.

Формат вывода
В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа 
K1   и  K  2   — количество купонов, которые останутся неиспользованными у Пети после этих N дней, и количество использованных им купонов соответственно.

В последующих  K 2   строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение  K1
максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.
"""
def cafe(n, array):
    sum = 0  # Сумма напитков стоимостью <= 100 (пьются без купонов)

    j = 0  # Вспомогательные переменные для итерации
    y = 0  # Индекс первого элемента > 100 (или конец массива)

    # Считаем сумму всех напитков <= 100 в начале массива
    while array[y] <= 100:
        sum += array[y]
        y += 1
        if y == n:  # Если все напитки дешёвые, возвращаем сумму
            return sum, 0, []

    # Константа для инициализации (значение "бесконечности" для алгоритма)
    CONST = (n + 1) * 301  

    # Массив для динамического программирования: sumarray[i][j] — минимальная сумма при j купонах
    sumarray = [0] * (n + 1 - y)  

    # Инициализация: заполняем "бесконечностями"
    for i in range(n - y):
        sumarray[i] = [CONST] * (n + 1)

    j = 1  # Текущее количество купонов
    sumarray[0][1] = array[y]  # База ДП: первый дорогой напиток

    # Если после дешёвых остался только один дорогой напиток
    if y == n - 1:
        return sumarray[0][1] + sum, 1, []

    # Основной цикл динамического программирования
    for i in range(1, n - y):
        if array[i + y] > 100:  # Если напиток дорогой
            sumarray[i][0] = sumarray[i - 1][1]  # Используем купон
            j = j + 1  # Увеличиваем возможное количество купонов
            for jj in range(1, j):
                # Выбираем минимум: брать купон или нет
                sumarray[i][jj] = min(
                    sumarray[i - 1][jj - 1] + array[i + y],  # Без купона
                    sumarray[i - 1][jj + 1]  # С купоном
                )
            # Крайний случай (все купоны использованы)
            sumarray[i][j] = sumarray[i - 1][j - 1] + array[i + y]
        else:  # Если напиток дешёвый
            for jj in range(0, j + 1):
                # Аналогично, но без увеличения числа купонов
                sumarray[i][jj] = min(
                    sumarray[i - 1][jj] + array[i + y],  # Просто добавляем
                    sumarray[i - 1][jj + 1]  # Либо используем купон
                )

    # Находим минимальную сумму и количество купонов
    min_index = 0
    min_value = CONST
    for mi in range(len(sumarray[i])):
        if sumarray[i][mi] <= min_value:
            min_value = sumarray[i][mi]
            min_index = mi

    # Восстанавливаем дни, когда использовались купоны
    num_day = []
    cur_sum = min_value
    cur_index = min_index
    j = len(sumarray[i]) - 1

    while i > 0:
        if array[i + y] > 100:  # Для дорогих напитков
            if cur_index == 0:
                cur_index = 1
                num_day.append(i + 1 + y)  # Запоминаем день
            elif cur_index == j:
                cur_index -= 1
            else:
                if sumarray[i - 1][cur_index + 1] == sumarray[i][cur_index]:
                    cur_index += 1
                    num_day.append(i + 1 + y)
                else:
                    cur_index -= 1
            j -= 1
        else:  # Для дешёвых напитков
            if cur_index != j and sumarray[i - 1][cur_index + 1] == sumarray[i][cur_index]:
                cur_index += 1
                num_day.append(i + 1 + y)
        i -= 1

    return min_value + sum, min_index, num_day  # Общая сумма, кол-во купонов, дни


# Ввод данных и вывод результата
n = int(input())  # Количество дней
array = [int(input()) for i in range(n)]  # Стоимость напитков каждый день

if n > 0:
    sum, min_index, num_day = cafe(n, array)
    print(sum)  # Общая минимальная сумма
    print(min_index, len(num_day))  # Количество оставшихся купонов и использованные дни
    for i in reversed(num_day):  # Выводим дни в обратном порядке
        print(i)
else:
    print(0)  # Если дней нет
    print(0, 0)  # Купоны и дни не нужны
